<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序（下）：如何用快排思想在O(n)内查找第K大元素？</title>
      <link href="/2020/06/25/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8O(n)%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9F/"/>
      <url>/2020/06/25/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8O(n)%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>归并排序和快速排序适合大规模的数据排序</p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>先把数据分成前后两部分，然后分别对前后两部分分别进行排列，再将排好序的两部分合并在一起。<br><img src="https://res.cloudinary.com/spss/image/upload/v1589380536/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F_sngv1c.png" alt="归并排序"><br>归并排序使用的就是<strong>分治思想</strong>，即将一个大的问题分解成小的子问题，小的子问题解决了，大问题也就解决了。<br>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">uint8_t</span> *a, <span class="keyword">uint32_t</span> p,<span class="keyword">uint32_t</span> q,<span class="keyword">uint32_t</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = p,j = q + <span class="number">1</span>,k = <span class="number">0</span>;<span class="comment">// 初始化变量i, j, k</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *temp = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>((r-p)*<span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));<span class="comment">// 申请一个大小跟A[p...r]一样的临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> start = i;</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">end</span> = q;</span><br><span class="line">    <span class="keyword">if</span>(j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        start = j;</span><br><span class="line">        <span class="built_in">end</span> = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组tmp</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= <span class="built_in">end</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++] = a[start++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将tmp中的数组拷贝回A[p...r]</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= r-p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[p+i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_c</span><span class="params">(<span class="keyword">uint8_t</span> *a, <span class="keyword">uint32_t</span> p, <span class="keyword">uint32_t</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> q = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取p到r之间的中间位置q</span></span><br><span class="line">    q = (p + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    merge_sort_c(a, p, q);</span><br><span class="line">    merge_sort_c(a, q + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span></span><br><span class="line">    merge(a,p,q,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">uint8_t</span> *a, <span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    merge_sort_c(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原地排序"><a href="#原地排序" class="headerlink" title="原地排序"></a>原地排序</h3><p>是否原地排序主要取决于合并函数，只要在有相同元素的时候把握好入上面temp数组的顺序就能保证稳定排序</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(nlog_{n})$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序（上）：为什么插入排序比冒泡排序更受欢迎？</title>
      <link href="/2020/06/25/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E%EF%BC%9F/"/>
      <url>/2020/06/25/%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的排序算法"><a href="#常用的排序算法" class="headerlink" title="常用的排序算法"></a>常用的排序算法</h2><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>归并排序</li><li>快速排序</li><li>计数排序</li><li>基数排序</li><li>桶排序</li></ul><h2 id="按照时间复杂度分类"><a href="#按照时间复杂度分类" class="headerlink" title="按照时间复杂度分类"></a>按照时间复杂度分类</h2><table><thead><tr><th align="center">排序算法</th><th align="center">时间复杂度</th><th align="center">是否基于比较</th></tr></thead><tbody><tr><td align="center">冒泡、插入、选择</td><td align="center">$O(n^2)$</td><td align="center">√</td></tr><tr><td align="center">快排、归并</td><td align="center">$O(nlog_{n})$</td><td align="center">√</td></tr><tr><td align="center">桶、计数、基数</td><td align="center">$O(n)$</td><td align="center">×</td></tr></tbody></table><h3 id="问题1：插入排序和冒泡排序的时间复杂度相同，但是为什么倾向于使用插入排序而不是冒泡排序？"><a href="#问题1：插入排序和冒泡排序的时间复杂度相同，但是为什么倾向于使用插入排序而不是冒泡排序？" class="headerlink" title="问题1：插入排序和冒泡排序的时间复杂度相同，但是为什么倾向于使用插入排序而不是冒泡排序？"></a>问题1：插入排序和冒泡排序的时间复杂度相同，但是为什么倾向于使用插入排序而不是冒泡排序？</h3><p><strong><em>学习排序算法除了原理外更重要的是学会如何评价、分析一个排序算法</em></strong></p><h2 id="排序算法分析"><a href="#排序算法分析" class="headerlink" title="排序算法分析"></a>排序算法分析</h2><ul><li><strong>排序算法的执行效率</strong><ul><li><strong>1、最好、最坏的情况，平均情况时间复杂度</strong><br>第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现</li><li><strong>2、时间复杂度的系数、常数 、低阶</strong></li><li><strong>3. 比较次数和交换（或移动）次数</strong></li></ul></li><li><strong>排序算法的内存消耗</strong><br>  算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外</li><li><strong>排序算法的稳定性</strong><br>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，<strong>稳定性</strong>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变</li></ul><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：</p><p><img src="https://res.cloudinary.com/spss/image/upload/v1588784013/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F_h3y7wb.png" alt="第一次冒泡操作的详细过程"></p><p>要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p><p><img src="https://res.cloudinary.com/spss/image/upload/v1588784012/images/%E5%86%92%E6%B3%A1%E7%BB%93%E6%9E%9C_mkcvef.png" alt="冒泡结果"></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//0表示无数据交换 1表示有数据交换</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j] ^ <span class="built_in">array</span>[j + <span class="number">1</span>];     <span class="comment">//异或后a=11^10=01</span></span><br><span class="line">                <span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j] ^ <span class="built_in">array</span>[j + <span class="number">1</span>]; <span class="comment">//异或后b=01^10=11(此时b为开始a的值)</span></span><br><span class="line">                <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j] ^ <span class="built_in">array</span>[j + <span class="number">1</span>];     <span class="comment">//异或后a=01^11=10(此时a为开始b的值)</span></span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//无数据交换提前退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>冒泡排序只涉及相邻数据的交换操作,只需要常量级的临时空间，时间复杂度为$O(n)$,属于<strong>原地排序算法</strong>。</li><li>相邻数据大小相等的时候不做数据交换，相同大小的数据在排序前后不会改变数据，所以冒泡排序属于<strong>稳定的排序算法</strong>。</li><li>最好情况下只需要排序一次，所以<strong>最好情况时间复杂度是 $O(n)$</strong>，最坏的情况下需要排序n次，所以<strong>最坏情况时间复杂度为 $O(n^2)$</strong>。</li></ul><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>数组中的数据分成两个部分，<strong>已排序区间</strong>和<strong>未排序区间</strong>。<br>初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中要到有一个何时合适的插入位置将其插入，并保证已排序区间数据一直有序，重复这个过程直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="https://res.cloudinary.com/spss/image/upload/v1588855881/images/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F_hropfu.png" alt="插入排序"></p><p>插入排序包含两种操作 <strong>元素的比较</strong> 和 <strong>元素的移动</strong>。</p><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insertion_sort</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> value = a[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j + <span class="number">1</span>] = a[j];  <span class="comment">//数据移动</span></span><br><span class="line">            j --;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不需要额外的空间，空间复杂度为$O(1)$,属于<strong>原地排序算法</strong></li><li>持原有的前后顺序不变，所以插入排序是<strong>稳定的排序算法</strong></li><li>最好是时间复杂度为 $O(n)$。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>,最坏是一个倒序的排列，时间复杂度是$O(n^2)$。</li></ul><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾</p><p><img src="https://res.cloudinary.com/spss/image/upload/v1588860579/images/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F_jkp2h4.png" alt="选择排序"></p><ul><li>选择排序空间复杂度是$O(1)$,是一种<strong>原地排序算法</strong></li><li>选择排序的最好最坏和平均时间复杂度都是$O(n^2)$。</li><li>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了，所以是<strong>不稳定的排序算法</strong></li></ul><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min_index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[min_index] &gt; a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min_index != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[min_index];</span><br><span class="line">            a[min_index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有序度"><a href="#有序度" class="headerlink" title="有序度"></a>有序度</h2><ul><li>有序度是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</li></ul><p><strong><em>有序元素对：a[i] &lt;= a[j], 如果i &lt; j。</em></strong></p><ul><li>我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong></li><li><strong>逆序度</strong> = <strong>满有序度</strong> - <strong>有序度</strong></li><li>我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了</li></ul><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><p>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序中数据的交换操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序中数据的移动操作：</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>一种更高效的插入排序算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> gap, i, j;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">arr[j + gap] = arr[j];</span><br><span class="line">arr[j + gap] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table><thead><tr><th></th><th>是否原地排序</th><th>是否稳定</th><th>最好</th><th>最坏</th><th>平均</th></tr></thead><tbody><tr><td>冒泡排序</td><td>√</td><td>√</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td></tr><tr><td>插入排序</td><td>√</td><td>√</td><td>$O(n)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td></tr><tr><td>选择排序</td><td>√</td><td>×</td><td>$O(n^2)$</td><td>$O(n^2)$</td><td>$O(n^2)$</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3、预处理：宏定义和条件编译</title>
      <link href="/2020/06/25/3%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%9A%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/"/>
      <url>/2020/06/25/3%E3%80%81%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%9A%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="预处理编程"><a href="#预处理编程" class="headerlink" title="预处理编程"></a>预处理编程</h2><p>首先，预处理指令都以符号“#”开头，这个你应该很熟悉了。但同时你也应该意识到，虽然都在一个源文件里，但它不属于 C++ 语言，它走的是预处理器，不受 C++ 语法规则的约束。</p><p><strong>预处理格式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#                              <span class="comment">// 预处理空行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __linux__                  <span class="comment">// 预处理检查宏是否存在</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> HAS_LINUX    1      <span class="comment">// 宏定义，有缩进</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                         <span class="comment">// 预处理条件语句结束</span></span></span><br><span class="line">#                              <span class="comment">// 预处理空行</span></span><br></pre></td></tr></table></figure><h2 id="包含文件（-include）"><a href="#包含文件（-include）" class="headerlink" title="包含文件（#include）"></a>包含文件（#include）</h2><p>先来说说最常用的预处理指令“#include”，它的作用是“包含文件”。注意，不是“包含头文件”，而是可以包含任意的文件。</p><p><strong>#include 可以用来包含大数组里的数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>  calc_table[] = &#123;  <span class="comment">// 非常大的一个数组，有几十行</span></span><br><span class="line">    <span class="number">0x00000000</span>, <span class="number">0x77073096</span>, <span class="number">0xee0e612c</span>, <span class="number">0x990951ba</span>,</span><br><span class="line">    <span class="number">0x076dc419</span>, <span class="number">0x706af48f</span>, <span class="number">0xe963a535</span>, <span class="number">0x9e6495a3</span>,</span><br><span class="line">    <span class="number">0x0edb8832</span>, <span class="number">0x79dcb8a4</span>, <span class="number">0xe0d5e91e</span>, <span class="number">0x97d2d988</span>,</span><br><span class="line">    <span class="number">0x09b64c2b</span>, <span class="number">0x7eb17cbd</span>, <span class="number">0xe7b82d07</span>, <span class="number">0x90bf1d91</span>,</span><br><span class="line">    ...                          </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把数据拆出来替换原来的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>  calc_table[] = &#123;</span><br><span class="line">#  include <span class="string">"calc_values.inc"</span>        <span class="comment">// 非常大的一个数组，细节被隐藏</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="宏定义（-define-undef）"><a href="#宏定义（-define-undef）" class="headerlink" title="宏定义（#define/#undef）"></a>宏定义（#define/#undef）</h2><p>封装小代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_tolower(c)      ((c &gt;= <span class="meta-string">'A'</span> &amp;&amp; c &lt;= <span class="meta-string">'Z'</span>) ? (c | 0x20) : c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_toupper(c)      ((c &gt;= <span class="meta-string">'a'</span> &amp;&amp; c &lt;= <span class="meta-string">'z'</span>) ? (c &amp; ~0x20) : c)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_memzero(buf, n)       (void) memset(buf, 0, n)</span></span><br></pre></td></tr></table></figure><p><strong><em>宏是没有作用域概念的，永远是全局生效</em></strong><br>所以，对于一些用来简化代码、起临时作用的宏，最好是用完后尽快用“#undef”取消定义，避免冲突的风险。像下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CUBE(a) (a) * (a) * (a)  <span class="comment">// 定义一个简单的求立方的宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CUBE(<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; CUBE(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 使用宏简化代码</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> CUBE                      <span class="comment">// 使用完毕后立即取消定义</span></span></span><br></pre></td></tr></table></figure><p>另一种做法是<strong>宏定义前先检查</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AUTH_PWD                  <span class="comment">// 检查是否已经有宏定义</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">undef</span> AUTH_PWD                <span class="comment">// 取消宏定义</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>                           <span class="comment">// 宏定义检查结束</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AUTH_PWD <span class="meta-string">"xxx"</span>           <span class="comment">// 重新宏定义</span></span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>预处理不属于 C++ 语言，过多的预处理语句会扰乱正常的代码，除非必要，应当少用慎用；</li><li>“#include”可以包含任意文件，所以可以写一些小的代码片段，再引进程序里；</li><li>头文件应该加上“Include Guard”，防止重复包含；</li><li>“#define”用于宏定义，非常灵活，但滥用文本替换可能会降低代码的可读性；</li><li>“条件编译”其实就是预处理编程里的分支语句，可以改变源码的形态，针对系统生成最合适的代码。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1、C++：生命周期和编程范式</title>
      <link href="/2020/06/25/1%E3%80%81C++%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/"/>
      <url>/2020/06/25/1%E3%80%81C++%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="C-程序的生命周期"><a href="#C-程序的生命周期" class="headerlink" title="C++程序的生命周期"></a>C++程序的生命周期</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>瀑布模型定义了软件或者项目的生命周期————从需求分析开始、经过设计、开发、测试等阶段，直到交付给用户。</p><h2 id="C-的生命阶段"><a href="#C-的生命阶段" class="headerlink" title="C++的生命阶段"></a>C++的生命阶段</h2><p><strong>编码（Coding）</strong>、<strong>预处理（Pre-processing）</strong>、<strong>编译（Compiling）</strong>、<strong>运行（Running）</strong>。</p><h2 id="C-的四个阶段"><a href="#C-的四个阶段" class="headerlink" title="C++的四个阶段"></a>C++的四个阶段</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>最基本的要求是遵循语言规范和设计文档，再高级一点的话，还有代码规范、注释规范、设计模式、编程惯用法，等等</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>要注意的是，预处理都以符号“#”开头，虽然是 C++ 程序的一部分，但严格来说不属于 C++ 语言的范畴，因为它走的是预处理器。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在编译阶段，C++ 程序——也就是经过预处理的源码——要经过编译器和链接器的“锤炼”，生成可以在计算机上运行的二进制机器码。</p><h3 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h3><p>编译阶段之后，有了可执行文件，C++ 程序就可以跑起来了，进入运行阶段。这个时候，“静态的程序”被载入内存，由 CPU 逐条语句执行，就形成了“动态的进程”。<br>在这个阶段，我们常做的是 <strong>GDB 调试</strong>、<strong>日志追踪</strong>、<strong>性能分析</strong>等，然后收集动态的数据、调整设计思路，再返回编码阶段，重走这个“瀑布模型”，实现“螺旋上升式”的开发。</p><h2 id="C-语言的编程范式（Paradigm）"><a href="#C-语言的编程范式（Paradigm）" class="headerlink" title="C++ 语言的编程范式（Paradigm）"></a>C++ 语言的编程范式（Paradigm）</h2><p>“<strong>编程范式</strong>”是一种“方法论”，就是指导你编写代码的一些思路、规则、习惯、定式和常用语。</p><p>编程范式和编程语言不同，有的范式只能用于少数特定的语言，有的范式却适用于大多数语言；有的语言可能只支持一种范式，有的语言却可能支持多种范式。<br>C++（11/14 以后）支持“<strong>面向过程</strong>”“<strong>面向对象</strong>”“<strong>泛型</strong>”“<strong>模板元</strong>”“<strong>函数式</strong>”这五种主要的编程范式。<br>其中，“面向过程”“面向对象”是基础，支撑着后三种范式。我画了一个“五环图”，圆环重叠表示有的语言特性会同时应用于多种范式，可以帮你理解它们的关系。<br><img src="https://res.cloudinary.com/spss/image/upload/v1589206355/images/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F_fjmpp1.png" alt="编程范式"></p><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>C++ 里最基本的一种编程范式。它的核心思想是“命令”，通常就是顺序执行的语句、子程序（函数），把任务分解成若干个步骤去执行，最终达成目标。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>它的核心思想是“抽象”和“封装”，倡导的是把任务分解成一些高内聚低耦合的对象，这些对象互相通信协作来完成任务。它强调对象之间的关系和接口，而不是完成任务的具体步骤。</p><h3 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h3><p>核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。</p><h3 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h3><p>它的核心思想是“类型运算”，操作的数据是编译时可见的“类型”，所以也比较特殊，代码只能由编译器执行，而不能被运行时的 CPU 执行。<br>模板元编程是一种高级、复杂的技术，C++ 语言对它的支持也比较少，更多的是以库的方式来使用，比如 type_traits、enable_if 等。</p><h3 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h3><p>核心思想是“一切皆可调用”，通过一系列连续或者嵌套的函数调用实现对数据的处理。</p><p><strong><em>所以常用的范式是“过程 + 对象 + 泛型”，再加上少量的“函数式”，慎用“模板元”。</em></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2、C++：Code style</title>
      <link href="/2020/06/25/2%E3%80%81C++%EF%BC%9ACode%20style/"/>
      <url>/2020/06/25/2%E3%80%81C++%EF%BC%9ACode%20style/</url>
      
        <content type="html"><![CDATA[<p><strong><em>任何人都能写出机器能看懂的代码，但只有优秀的程序员才能写出人能看懂的代码</em></strong></p><p>参考：<br><a href="http://openresty.org/cn/c-coding-style-guide.html" target="_blank" rel="noopener">OpenResty® C 代码风格指南</a></p><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><h3 id="恰当地运用空格和空行"><a href="#恰当地运用空格和空行" class="headerlink" title="恰当地运用空格和空行"></a>恰当地运用空格和空行</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">原始代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!value.contains(<span class="string">"xxx"</span>))&#123;</span><br><span class="line">  LOGIT(WARNING,<span class="string">"value is incomplete.\n"</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> suffix[<span class="number">16</span>]=<span class="string">"xxx"</span>;</span><br><span class="line"><span class="keyword">int</span>  data_len = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(!value.empty()&amp;&amp;value.contains(<span class="string">"tom"</span>))&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name=value.c_str();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_LEN;i++)&#123;</span><br><span class="line">    ...  <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(name);i++)&#123;</span><br><span class="line">    ... <span class="comment">// do something  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改善之后的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!value.contains(<span class="string">"xxx"</span>)) &#123;                    <span class="comment">// if后&#123;前有空格</span></span><br><span class="line">  LOGIT(WARNING, <span class="string">"value is incomplete.\n"</span>)        <span class="comment">// 逗号后有空格</span></span><br><span class="line">  <span class="keyword">return</span>;                                      <span class="comment">// 逻辑联系紧密就不用加空行</span></span><br><span class="line">&#125;</span><br><span class="line">                                                  <span class="comment">// 新增空行分隔段落</span></span><br><span class="line"><span class="keyword">char</span> suffix[<span class="number">16</span>] = <span class="string">"xxx"</span>;                          <span class="comment">// 等号两边有空格</span></span><br><span class="line"><span class="keyword">int</span> data_len = <span class="number">100</span>;                            <span class="comment">// 逻辑联系紧密就不用加空行</span></span><br><span class="line">                                                  <span class="comment">// 新增空行分隔段落</span></span><br><span class="line"><span class="keyword">if</span> (!value.empty() &amp;&amp; value.contains(<span class="string">"tom"</span>)) &#123;   <span class="comment">// &amp;&amp;两边有空格</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name = value.c_str();              <span class="comment">// 等号两边有空格</span></span><br><span class="line">                                                  <span class="comment">// 新增空行分隔段落</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_LEN; i++)&#123;              <span class="comment">// =;&lt;处有空格</span></span><br><span class="line">    ...  <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">                                                  <span class="comment">// 新增空行分隔段落</span></span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;                                  <span class="comment">// 等号两边有空格</span></span><br><span class="line">                                                  <span class="comment">// 新增空行分隔段落</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(name); i++)&#123;          <span class="comment">// =;&lt;处有空格</span></span><br><span class="line">    ... <span class="comment">// do something  </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h2><ul><li>匈牙利命名法</li></ul><p>就是给成员变量加“m_”前缀（member），给全局变量加“g_”前缀（global），比如 m_count、g_total，这样一看就知道了变量的作用域，在大型程序里还是挺有用的。</p><ul><li>第二种风格叫驼峰式命名法（CamelCase）</li></ul><p>主张单词首字母大写，比如 MyJobClass、tryToLock，但这种风格在 C++ 世界里的接受程度不是太高。</p><ul><li>第三种风格叫“snake_case”</li></ul><p>用的是全小写，单词之间用下划线连接。这是 C 和 C++ 主要采用的命名方式，看一下标准库，里面的 vector、unordered_set、shrink_to_fit 都是这样。</p><h3 id="起名的四个规则"><a href="#起名的四个规则" class="headerlink" title="起名的四个规则"></a>起名的四个规则</h3><ul><li>变量、函数名和名字空间用 snake_case，全局变量加“g_”前缀；</li><li>自定义类名用 <strong>CamelCase</strong>，成员函数用 snake_case，成员变量加“m_”前缀；</li><li>宏和常量应当全大写，单词之间用下划线连接；</li><li>尽量不要用下划线作为变量的前缀或者后缀（比如 _local、name_），很难识别。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MAX_PATH_LEN  256             <span class="comment">//常量，全大写</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_sys_flag;                        <span class="comment">// 全局变量，加g_前缀</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> linux_sys &#123;                <span class="comment">// 名字空间，全小写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">get_rlimit_core</span><span class="params">()</span></span>;               <span class="comment">// 函数，全小写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilePath</span> <span class="title">final</span>                 // 类名，首字母大写</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_path</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>;    <span class="comment">// 函数，全小写</span></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">  <span class="built_in">string</span> m_path;                      <span class="comment">// 成员变量，m_前缀 </span></span><br><span class="line">  <span class="keyword">int</span>    m_level;                     <span class="comment">// 成员变量，m_前缀</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><em>变量 / 函数的名字长度与它的作用域成正比</em></strong>,也就是说，局部变量 / 函数名可以短一点，而全局变量 / 函数名应该长一点。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>对于 C++ 来说，也有一个类似的工具叫 Doxgen，用好它甚至可以直接从源码生成完整的 API 文档</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>用好空格和空行，多留白，让写代码就像写诗一样；</li><li>给变量、函数、类起个好名字，你的代码就成功了一半；</li><li>给变量、函数、类再加上注释，让代码自带文档，就成了“人能够看懂的代码”</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gcc</title>
      <link href="/2020/06/24/gcc/"/>
      <url>/2020/06/24/gcc/</url>
      
        <content type="html"><![CDATA[<h1 id="GCC记录"><a href="#GCC记录" class="headerlink" title="GCC记录"></a>GCC记录</h1><h2 id="预处理选项（Preprocessor-Options）"><a href="#预处理选项（Preprocessor-Options）" class="headerlink" title="预处理选项（Preprocessor Options）"></a>预处理选项（Preprocessor Options）</h2><p><strong><code>-MMD -MP -MF&quot;$(@:%.o=%.d)&quot;</code></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cmake</title>
      <link href="/2020/06/24/cmake/"/>
      <url>/2020/06/24/cmake/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake记录"><a href="#CMake记录" class="headerlink" title="CMake记录"></a>CMake记录</h1><h2 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1 环境准备"></a>1 环境准备</h2><h3 id="1-1-设置交叉编译目标平台"><a href="#1-1-设置交叉编译目标平台" class="headerlink" title="1.1 设置交叉编译目标平台"></a>1.1 设置交叉编译目标平台</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 软件平台</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Generic)</span><br><span class="line"><span class="comment"># 处理器架构</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_HOST_SYSTEM_PROCESSOR arm)</span><br></pre></td></tr></table></figure><h3 id="1-2-设置交叉编译工具"><a href="#1-2-设置交叉编译工具" class="headerlink" title="1.2 设置交叉编译工具"></a>1.2 设置交叉编译工具</h3><ul><li><input disabled="" type="checkbox"> 针对每项添加说明 </li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(PREFIX <span class="string">"arm-none-eabi-"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">"$&#123;PREFIX&#125;gcc"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ASM_COMPILER <span class="string">"$&#123;PREFIX&#125;gcc"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">"$&#123;PREFIX&#125;g++"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_OBJCOPY <span class="string">"$&#123;PREFIX&#125;objcopy"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_AR <span class="string">"$&#123;PREFIX&#125;ar"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SIZE <span class="string">"$&#123;PREFIX&#125;size"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br></pre></td></tr></table></figure><h2 id="2-添加文件"><a href="#2-添加文件" class="headerlink" title="2 添加文件"></a>2 添加文件</h2><h3 id="2-1-添加头文件"><a href="#2-1-添加头文件" class="headerlink" title="2.1 添加头文件"></a>2.1 添加头文件</h3><p>命令1:<code>target_include_directories(RigelEditor PUBLIC ./include/rgeditor)</code></p><p>命令2：<code>include_directories(&quot;/opt/MATLAB/R2012a/extern/include&quot;)</code></p><p>区别：两者都是将include目录添加到目标区域中，但是<code>include_directories</code>是对整个项目添加，<code>target_include_directories</code>CMake中针对的目标进行添加。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置头文件路径</span></span><br><span class="line"><span class="keyword">set</span>(C_INCLUDES </span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Core/Inc"</span></span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Drivers/STM32L4xx_HAL_Driver/Inc"</span></span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Drivers/STM32L4xx_HAL_Driver/Inc/Legacy"</span></span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Drivers/CMSIS/Device/ST/STM32L4xx/Include"</span></span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Drivers/CMSIS/Include"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PRO_TARGET&#125;</span>.elf PRIVATE  <span class="variable">$&#123;C_INCLUDES&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-添加源文件"><a href="#2-2-添加源文件" class="headerlink" title="2.2 添加源文件"></a>2.2 添加源文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加源文件路径</span></span><br><span class="line"><span class="keyword">set</span>(C_SOURCES </span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Core/Src/main.c"</span></span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/Core/Src/stm32l4xx_it.c"</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-3-添加汇编文件"><a href="#2-3-添加汇编文件" class="headerlink" title="2.3 添加汇编文件"></a>2.3 添加汇编文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加汇编源文件</span></span><br><span class="line"><span class="keyword">set</span> (ASM_SOURCES</span><br><span class="line">    <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/startup_stm32l475xx.s"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="3-添加编译标志"><a href="#3-添加编译标志" class="headerlink" title="3 添加编译标志"></a>3 添加编译标志</h2><h3 id="3-1-针对平台标志"><a href="#3-1-针对平台标志" class="headerlink" title="3.1 针对平台标志"></a>3.1 针对平台标志</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpu</span></span><br><span class="line"><span class="keyword">set</span>(CPU <span class="string">"-mcpu=cortex-m4"</span>)</span><br><span class="line"><span class="comment"># fpu</span></span><br><span class="line"><span class="keyword">set</span>(FPU <span class="string">"-mfpu=fpv4-sp-d16"</span>)</span><br><span class="line"><span class="comment"># float-abi</span></span><br><span class="line"><span class="keyword">set</span>(FLOAT-ABI <span class="string">"-mfloat-abi=hard"</span>)</span><br><span class="line"><span class="comment"># mcu</span></span><br><span class="line"><span class="keyword">set</span>(MCU <span class="string">"$&#123;CPU&#125; -mthumb $&#123;FPU&#125; $&#123;FLOAT-ABI&#125;"</span>)</span><br></pre></td></tr></table></figure><h3 id="3-2-汇编标志"><a href="#3-2-汇编标志" class="headerlink" title="3.2 汇编标志"></a>3.2 汇编标志</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(ASFLAGS <span class="string">"$&#123;MCU&#125; $&#123;AS_DEFS&#125; $&#123;AS_INCLUDES&#125; $&#123;OPT&#125; -Wall -fdata-sections -ffunction-sections -x assembler-with-cpp"</span> )</span><br></pre></td></tr></table></figure><h3 id="3-3-C标志"><a href="#3-3-C标志" class="headerlink" title="3.3 C标志"></a>3.3 C标志</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CFLAGS <span class="string">"$&#123;MCU&#125; $&#123;C_DEFS&#125; $&#123;OPT&#125; -Wall -fdata-sections -ffunction-sections"</span>)</span><br></pre></td></tr></table></figure><h2 id="4-编译声明"><a href="#4-编译声明" class="headerlink" title="4 编译声明"></a>4 编译声明</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>(</span><br><span class="line">    <span class="string">"-DUSE_HAL_DRIVER"</span></span><br><span class="line">    <span class="string">"-DSTM32L475xx"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="5-链接设置"><a href="#5-链接设置" class="headerlink" title="5 链接设置"></a>5 链接设置</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置链接脚本</span></span><br><span class="line"><span class="keyword">set</span>(LDSCRIPT <span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/STM32L475VETx_FLASH.ld"</span>)</span><br><span class="line"><span class="comment"># 设置链接库</span></span><br><span class="line"><span class="keyword">set</span>(LIBS <span class="string">"-lc -lm -lnosys"</span>)</span><br><span class="line"><span class="keyword">set</span>(LIBDIR <span class="string">""</span>)</span><br><span class="line"><span class="keyword">set</span>(LDFLAGS <span class="string">"$&#123;MCU&#125; -specs=nano.specs -T$&#123;LDSCRIPT&#125; $&#123;LIBDIR&#125; $&#123;LIBS&#125; -Wl,-Map=$&#123;PROJECT_BINARY_DIR&#125;/$&#123;PRO_TARGET&#125;.map,--cref -Wl,--gc-sections"</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="variable">$&#123;LDFLAGS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="6-执行自定义命令"><a href="#6-执行自定义命令" class="headerlink" title="6 执行自定义命令"></a>6 执行自定义命令</h2><h3 id="6-1-显示代码大小"><a href="#6-1-显示代码大小" class="headerlink" title="6.1 显示代码大小"></a>6.1 显示代码大小</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="variable">$&#123;PRO_TARGET&#125;</span>.elf</span><br><span class="line">    POST_BUILD </span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_SIZE&#125;</span> <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;PRO_TARGET&#125;</span>.elf</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="6-2-将elf转换为hex"><a href="#6-2-将elf转换为hex" class="headerlink" title="6.2 将elf转换为hex"></a>6.2 将elf转换为hex</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="variable">$&#123;PRO_TARGET&#125;</span>.elf</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_OBJCOPY&#125;</span> </span><br><span class="line">    -O ihex </span><br><span class="line">    <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;PRO_TARGET&#125;</span>.elf </span><br><span class="line">    <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;PRO_TARGET&#125;</span>.hex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="6-3-将elf转换为bin"><a href="#6-3-将elf转换为bin" class="headerlink" title="6.3 将elf转换为bin"></a>6.3 将elf转换为bin</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="variable">$&#123;PRO_TARGET&#125;</span>.elf</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_OBJCOPY&#125;</span> </span><br><span class="line">    -O binary </span><br><span class="line">    <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;PRO_TARGET&#125;</span>.elf </span><br><span class="line">    <span class="variable">$&#123;EXECUTABLE_OUTPUT_PATH&#125;</span>/<span class="variable">$&#123;PRO_TARGET&#125;</span>.bin</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="6-4-命令说明"><a href="#6-4-命令说明" class="headerlink" title="6.4 命令说明"></a>6.4 命令说明</h3><ul><li><input disabled="" type="checkbox"> 等待添加</li></ul><h3 id="6-5-标志说明"><a href="#6-5-标志说明" class="headerlink" title="6.5 标志说明"></a>6.5 标志说明</h3><ul><li>PRE_BUILD - run before all other dependencies</li><li>PRE_LINK - run after other dependencies</li><li>POST_BUILD - run after the target has been built</li></ul><h2 id="7-变量和缓存"><a href="#7-变量和缓存" class="headerlink" title="7 变量和缓存"></a>7 变量和缓存</h2><h3 id="7-1-局部变量"><a href="#7-1-局部变量" class="headerlink" title="7.1 局部变量"></a>7.1 局部变量</h3><p>CMakeLists.txt相当于一个函数，第一个执行的CMakeLists.txt相当于主函数，正常设置的变量不能跨越CMakeLists.txt文件，相当于局部变量只在当前函数域里面作用一样。但是当使用include()直接进行.cmake文件的引入时，可以实现变量的通用引用。</p><h3 id="7-2-缓存变量"><a href="#7-2-缓存变量" class="headerlink" title="7.2 缓存变量"></a>7.2 缓存变量</h3><p>缓存变量就是cache变量，相当于全局变量，都是在第一个执行的CMakeLists.txt里面被设置的，不过在子项目的CMakeLists.txt文件里面也是可以修改这个变量的，此时会影响父目录的CMakeLists.txt，这些变量用来配置整个工程，配置好之后对整个工程使用。 设置缓存变量: <code>set(MY_CACHE_VALUE &quot;cache_value&quot; CACHE INTERNAL &quot;THIS IS MY CACHE VALUE&quot;)</code>；//THIS IS MY CACHE VALUE，这个字符串相当于对变量的描述说明，不能省略，但可以自己随便定义。</p><h3 id="7-3-环境变量"><a href="#7-3-环境变量" class="headerlink" title="7.3 环境变量"></a>7.3 环境变量</h3><p>设置环境变量：<code>set(ENV{variable_name} value)</code> 获取环境变量：<code>$ENV{variable_name}</code></p><h3 id="7-4-内置变量"><a href="#7-4-内置变量" class="headerlink" title="7.4 内置变量"></a>7.4 内置变量</h3><p>CMake中包含大量的内置变量，和自定义的变量相同，常用的有以下：</p><ul><li><strong>CMAKE_C_COMPILER</strong>：指定C编译器</li><li><strong>CMAKE_CXX_COMPILER</strong>：指定C++编译器</li><li><strong>EXECUTABLE_OUTPUT_PATH</strong>：指定可执行文件的存放路径</li><li><strong>LIBRARY_OUTPUT_PATH</strong>：指定库文件的放置路径</li><li><strong>CMAKE_CURRENT_SOURCE_DIR</strong>：当前处理的CMakeLists.txt所在的路径</li><li><strong>CMAKE_BUILD_TYPE</strong>：控制构建的时候是Debug还是Release命令：    <code>set(CMAKE_BUILD_TYPE Debug)</code></li><li><strong>CMAKE_SOURCR_DIR</strong>：无论外部构建还是内部构建，都指的是工程的顶层目录</li><li><strong>CMAKE_BINARY_DIR</strong>：内部构建指的是工程顶层目录，外部构建指的是工程发生编译的目录</li><li><strong>CMAKE_CURRENT_LIST_LINE</strong>：输出这个内置变量所在的行。</li></ul><h2 id="8-target"><a href="#8-target" class="headerlink" title="8 target_"></a>8 target_</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>windows右键菜单启动vscode</title>
      <link href="/2020/06/24/windows%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%90%AF%E5%8A%A8vscode/"/>
      <url>/2020/06/24/windows%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%E5%90%AF%E5%8A%A8vscode/</url>
      
        <content type="html"><![CDATA[<h1 id="windows右键菜单启动vscode"><a href="#windows右键菜单启动vscode" class="headerlink" title="windows右键菜单启动vscode"></a>windows右键菜单启动vscode</h1><ul><li>1、新建1.reg文件</li><li>2、找到vscode程序Code.exe所在的目录,比如我的是<blockquote><p>D:\Program Files\Microsoft VS Code\Code.exe</p></blockquote></li><li>3、复制以下内容到1.reg<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\VSCode]</span><br><span class="line">@="Open with Code"</span><br><span class="line">"Icon"="D:\\Program Files\\Microsoft VS Code\\Code.exe"</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\VSCode\command]</span><br><span class="line">@="\"D:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%1\""</span><br><span class="line"></span><br><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\VSCode]</span><br><span class="line">@="Open with Code"</span><br><span class="line">"Icon"="D:\\Program Files\\Microsoft VS Code\\Code.exe"</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]</span><br><span class="line">@="\"D:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""</span><br><span class="line"></span><br><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]</span><br><span class="line">@="Open with Code"</span><br><span class="line">"Icon"="D:\\Program Files\\Microsoft VS Code\\Code.exe"</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]</span><br><span class="line">@="\"D:\\Program Files\\Microsoft VS Code\\Code.exe\" \"%V\""</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-12-05-温控器接口文档</title>
      <link href="/2020/06/24/2019-12-05-%E6%B8%A9%E6%8E%A7%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/"/>
      <url>/2020/06/24/2019-12-05-%E6%B8%A9%E6%8E%A7%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="上品尚生温控器接口文档"><a href="#上品尚生温控器接口文档" class="headerlink" title="上品尚生温控器接口文档"></a>上品尚生温控器接口文档</h1><hr><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><table border="1">    <caption>表1 报文格式</caption>    <tr align="center">        <th>Domain</th>        <th>Description</th>        <th>Length(bytes)</th>    </tr>    <tr>        <td>Magic num</td>        <td>固定值0xAA</td>        <td>1</td>    </tr>    <tr>        <td>Length</td>        <td>报文长度,发送的所有字节相加，最大长度72</td>        <td>1</td>    </tr>    <tr>        <td>Version</td>        <td>协议版本号，固定值0x10</td>        <td>1</td>    </tr>    <tr>        <td>Msgtype</td>        <td>消息类型（详细见表2）</td>        <td>1</td>    </tr>    <tr>        <td>DeviceType</td>        <td>设备类型</td>        <td>1</td>    </tr>    <tr>        <td>DeviceIndex</td>        <td>设备索引,固定值00</td>        <td>1</td>    </tr>    <tr>        <td>PacketID</td>        <td>报文序列号。由请求设备产生，响应和请求中Packet ID应相同</td>        <td>1</td>    </tr>    <tr>        <td>Type1</td>        <td>属性类型</td>        <td>1</td>    </tr>    <tr>        <td>Data1</td>        <td>属性值</td>        <td>4</td>    </tr>    <tr>        <td>...</td>        <td>...</td>        <td>...</td>    </tr>    <tr>        <td>...</td>        <td>...</td>        <td>...</td>    </tr>    <tr>        <td>Typen</td>        <td>属性类型</td>        <td>1</td>    </tr>    <tr>        <td>Datan</td>        <td>属性值</td>        <td>4</td>    </tr></table><blockquote><p><em>注：写数据的时候发送Type+Data，读数据的时候只发送Type</em></p></blockquote><h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><table border="1">    <caption>表2 消息类型</caption>    <tr align="center">        <th>Msgtyp</th>        <th>Description</th>        <th>发送方</th>    </tr>    <tr>        <td>0x00</td>        <td>要求设备注册</td>        <td>网关</td>    </tr>    <tr>        <td>0x01</td>        <td>设备注册响应</td>        <td>设备</td>    </tr>    <tr>        <td>0x02</td>        <td>要求设备离网</td>        <td>网关</td>    </tr>    <tr>        <td>0x03</td>        <td>设备操作</td>        <td>网关</td>    </tr>    <tr>        <td>0x04</td>        <td>设备操作结果</td>        <td>设备</td>    </tr>    <tr>        <td>0x05</td>        <td>设备状态查询</td>        <td>网关</td>    </tr>    <tr>        <td>0x06</td>        <td>设备状态上报</td>        <td>设备</td>    </tr>    <tr>        <td>0x07</td>        <td>设备定位</td>        <td>设备</td>    </tr></table><blockquote><p><em>以上关于设备的消息类型应全部实现</em></p></blockquote><h2 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h2><table><thead><tr><th>DeviceType</th><th>Description</th></tr></thead><tbody><tr><td>05</td><td>地暖</td></tr><tr><td>—</td><td></td></tr></tbody></table><hr><h2 id="属性类型和属性值定义"><a href="#属性类型和属性值定义" class="headerlink" title="属性类型和属性值定义"></a>属性类型和属性值定义</h2><table border="1">    <caption>Type类型和Data数据</caption>    <tr align="center">        <th>Type</th>        <th>Value</th>        <th>Data</th>        <th>Value</th>    </tr>    <tr>        <td rowspan="5" align="center">响应结果</td>        <td rowspan="5" align="center">0x00</td>        <td align="center">操作成功</td>        <td align="center">00</td>    </tr>    <tr>        <td align="center">操作失败</td>        <td align="center">01</td>    </tr>    <tr>        <td align="center">非法请求</td>        <td align="center">02</td>    </tr>        <tr>        <td align="center">参数错误</td>        <td align="center">03</td>    </tr>        <tr>        <td align="center">系统忙</td>        <td align="center">04</td>    </tr>    <tr>        <td rowspan="2" align="center">故障</td>        <td rowspan="2" align="center">0xFF</td>        <td align="center">ERROR_SOCKET</td>        <td align="center">01</td>    </tr>    <tr>        <td align="center">ERROR_PURIFIER</td>        <td align="center">02</td>    </tr>    <tr>        <td rowspan="3" align="center">设备工作状态</td>        <td rowspan="3" align="center">0x03</td>        <td align="center">STANDBY</td>        <td align="center">0x02</td>    </tr>    <tr>        <td align="center">设备工作</td>        <td align="center">0x01</td>    </tr>     <tr>        <td align="center">停止工作</td>        <td align="center">0x00</td>    </tr>    <tr>        <td align="center">设备设定温度</td>        <td align="center">0x09</td>        <td align="center">温度取值范围</td>        <td align="center">0~100</td>    </tr>    <tr>        <td align="center">环境温度数据</td>        <td align="center">0x40</td>        <td align="center">取值范围</td>        <td >带1位小数，数据除以10为当前数据，单位摄氏度。如收到数据0x0115，数值为227，当前温度即为22.7度</td>    </tr></table><h2 id="设备定位"><a href="#设备定位" class="headerlink" title="设备定位"></a>设备定位</h2><ul><li>地暖设备定位</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th></tr></thead><tbody><tr><td>AA</td><td>07</td><td>10</td><td>07</td><td>05</td><td>00</td><td>00</td></tr></tbody></table><blockquote><p><em>设备需要实现定位功能，定位功能需要用特定方式主动上报，比如按键</em></p></blockquote><h2 id="设备入网"><a href="#设备入网" class="headerlink" title="设备入网"></a>设备入网</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+JOIN</span><br></pre></td></tr></table></figure><h2 id="设备离网"><a href="#设备离网" class="headerlink" title="设备离网"></a>设备离网</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AT+LEAVE</span><br></pre></td></tr></table></figure><ul><li>设备入网离网一般由设备发起（<strong>按键</strong>），发送AT+JOIN申请加入网络，设备收到要求注册报文或者状态查询报文后将状态修改为已经入网状态。</li><li>设备再15秒内未收到任何消息则将网络状态设置为离网状态。</li><li>设备主动离网发送AT+LEAVE命令。</li><li><strong>设备屏幕上要显示设备的网络状态</strong></li></ul><h2 id="消息举例"><a href="#消息举例" class="headerlink" title="消息举例"></a>消息举例</h2><h3 id="设备注册"><a href="#设备注册" class="headerlink" title="设备注册"></a>设备注册</h3><ul><li>请求消息：要求地暖注册，网关-&gt;设备</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th></tr></thead><tbody><tr><td>AA</td><td>07</td><td>10</td><td>00</td><td>FF</td><td>00</td><td>ED</td></tr></tbody></table><ul><li>响应消息：地暖注册响应，设备-&gt;网关</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th></tr></thead><tbody><tr><td>AA</td><td>07</td><td>10</td><td>01</td><td>05</td><td>00</td><td>ED</td></tr></tbody></table><h3 id="环境温度读取"><a href="#环境温度读取" class="headerlink" title="环境温度读取"></a>环境温度读取</h3><ul><li>请求消息：向地暖请求温度数据，网关-&gt;设备</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th><th>Type</th></tr></thead><tbody><tr><td>AA</td><td>08</td><td>10</td><td>05</td><td>05</td><td>00</td><td>ED</td><td>40</td></tr></tbody></table><ul><li>响应消息：地暖返回数据22.7℃，设备-&gt;网关</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th><th>Type</th><th>Data</th></tr></thead><tbody><tr><td>AA</td><td>0C</td><td>10</td><td>06</td><td>05</td><td>00</td><td>ED</td><td>40</td><td>00000115</td></tr></tbody></table><h3 id="全部状态读取"><a href="#全部状态读取" class="headerlink" title="全部状态读取"></a>全部状态读取</h3><ul><li>请求消息：广播读取设备的全部信息</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msgtype</th><th>DeviceType</th><th>DeviceIndex</th><th>PacketID</th></tr></thead><tbody><tr><td>AA</td><td>07</td><td>10</td><td>05</td><td>FF</td><td>00</td><td>ED</td></tr></tbody></table><ul><li>响应消息：设备-&gt;网关，返回地暖设备的全部信息（设备工作状态、空调系统主机模式、温控器工作模式、风速、环境温度数据）</li></ul><table><thead><tr><th>Magic num</th><th>Length</th><th>Version</th><th>Msg type</th><th>Device Type</th><th>Device Index</th><th>Packet ID</th><th>Type1</th><th>Data1</th></tr></thead><tbody><tr><td>AA</td><td>2A</td><td>10</td><td>06</td><td>05</td><td>00</td><td>ED</td><td>03</td><td>00 00 00 01</td></tr><tr><td>Type2</td><td>Data2</td><td>Type3</td><td>Data3</td><td>Type4</td><td>Data4</td><td>Type5</td><td>Data5</td><td></td></tr><tr><td>04</td><td>00 00 00 00</td><td>05</td><td>00 00 00 00</td><td>06</td><td>00 00 00 02</td><td>40</td><td>00 00 01 15</td><td></td></tr></tbody></table><h2 id="设备状态上报附加规则"><a href="#设备状态上报附加规则" class="headerlink" title="设备状态上报附加规则"></a>设备状态上报附加规则</h2><ul><li>手动修改设备（温控器）的参数需要及时上报到网关，消息类型为0x06,PacketID为0x00，<br>比如手动修改温控器的模式需要及时主动上报</li><li>每两个以Magic num开头的数据包之间最少间隔<strong>50ms</strong></li><li>水阀状态改变要及时上报到网关</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2019-12-15-shell记录</title>
      <link href="/2020/06/24/2019-12-15-shell%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/06/24/2019-12-15-shell%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="shell记录"><a href="#shell记录" class="headerlink" title="shell记录"></a>shell记录</h1><h2 id="shell-变量"><a href="#shell-变量" class="headerlink" title="shell 变量"></a>shell 变量</h2><ul><li>显式赋值<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">"abc"</span></span><br></pre></td></tr></table></figure></li><li>隐式赋值<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(ls /etc)</span><br></pre></td></tr></table></figure></li><li>只读变量<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myurl=<span class="string">"www.baidu.com"</span></span><br><span class="line"><span class="built_in">readonly</span> myurl</span><br></pre></td></tr></table></figure></li><li>使用变量<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">或者使用花括号帮助确定边界</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br></pre></td></tr></table></figure></li><li>删除变量<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> num</span><br><span class="line"><span class="built_in">unset</span>只能删除只读变量</span><br></pre></td></tr></table></figure></li><li>从命令行键入变量<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> var</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br></pre></td></tr></table></figure>shell字符串</li></ul><hr><ul><li><p>字符串单双引号区别</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>可以使用双引号拼接字符串；<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"tom"</span></span><br><span class="line">str1=<span class="string">"hello"</span><span class="variable">$str</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取字符串长度</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>提取子字符串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1:1:2&#125;</span></span><br><span class="line">这个使用sh执行一直报错，改成bash后执行成功过</span><br><span class="line">原因是ubuntu的sh是指向dash的，而不是bash</span><br></pre></td></tr></table></figure><p>查找子字符串</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> io`  <span class="comment"># 输出 4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><blockquote><p>数组名=(值1 值2 … 值n)</p></blockquote><h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;数组名[下标]&#125;</span></span><br><span class="line"></span><br><span class="line">使用@可以获取数组的全部元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arrayname[@]&#125;</span></span><br></pre></td></tr></table></figure><h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="shell多行注释"><a href="#shell多行注释" class="headerlink" title="shell多行注释"></a>shell多行注释</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line">或者</span><br><span class="line">:&lt;&lt;<span class="string">'</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line">或者</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h4 id="if语法格式"><a href="#if语法格式" class="headerlink" title="if语法格式"></a>if语法格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ···</span><br><span class="line">    command3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">或者写在一行</span><br><span class="line"><span class="keyword">if</span> [$(ps -ef | grep -c  <span class="string">"ssh"</span>) -gt 1];<span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"true"</span>;<span class="keyword">fi</span></span><br><span class="line">grep -c</span><br></pre></td></tr></table></figure><blockquote><p>注：grep -c是对找到的内容进行计数</p></blockquote><h4 id="if与test结合使用"><a href="#if与test结合使用" class="headerlink" title="if与test结合使用"></a>if与test结合使用</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=$[2*3]</span><br><span class="line">num2=$[1+5]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> $[num1] -eq $[num2]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字相等!'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">'两个数字不相等!'</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h4 id="for循环格式"><a href="#for循环格式" class="headerlink" title="for循环格式"></a>for循环格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">或者写成一行</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN; <span class="keyword">do</span> command1; command2… <span class="keyword">done</span>;</span><br></pre></td></tr></table></figure><h4 id="while格式"><a href="#while格式" class="headerlink" title="while格式"></a>while格式</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="Linux-let-命令"><a href="#Linux-let-命令" class="headerlink" title="Linux let 命令"></a>Linux let 命令</h2><p>let是bash中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上$来表示变量，如果表达式中包含了空格或者特殊字符则需要使用单引号括起来</p><blockquote><p>格式：let arg [arg ···]</p></blockquote><p>例如自加操作: let num++</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打印数组内容</span><br><span class="line">array=(<span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"xyz"</span> <span class="string">"mnu"</span>)</span><br><span class="line"><span class="keyword">while</span> ((i &lt; <span class="variable">$&#123;#array[@]&#125;</span>))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array[i]&#125;</span></span><br><span class="line"><span class="built_in">let</span> i++</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="shell获取环境变量"><a href="#shell获取环境变量" class="headerlink" title="shell获取环境变量"></a>shell获取环境变量</h2><h4 id="获取当前路径"><a href="#获取当前路径" class="headerlink" title="获取当前路径"></a>获取当前路径</h4><ul><li>第一种方式<br><code>work_path=$(dirname $(readlink -f $0))</code></li><li>第二种方式<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work_path=$(dirname <span class="variable">$0</span>)</span><br><span class="line"><span class="built_in">cd</span> ./<span class="variable">$work_path</span> <span class="comment">#当前位置跳转到脚本位置</span></span><br><span class="line">work_path=$(<span class="built_in">pwd</span>)  <span class="comment">#取到脚本目录</span></span><br></pre></td></tr></table></figure>echo</li></ul><hr><h5 id="1、显示普通字符串"><a href="#1、显示普通字符串" class="headerlink" title="1、显示普通字符串"></a>1、显示普通字符串</h5><h5 id="2、显示转义符"><a href="#2、显示转义符" class="headerlink" title="2、显示转义符"></a>2、显示转义符</h5><p><code>echo &quot;\&quot;It is a test\&quot;&quot;</code></p><h5 id="3、显示变量"><a href="#3、显示变量" class="headerlink" title="3、显示变量"></a>3、显示变量</h5><h5 id="4-显示换行"><a href="#4-显示换行" class="headerlink" title="4.显示换行"></a>4.显示换行</h5><p><code>echo -e &quot;OK! \n&quot; # -e 开启转义</code></p><h5 id="5、显示不换行"><a href="#5、显示不换行" class="headerlink" title="5、显示不换行"></a>5、显示不换行</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"OK! \c"</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"It is a test"</span></span><br></pre></td></tr></table></figure><h5 id="6、显示结果定向至文件"><a href="#6、显示结果定向至文件" class="headerlink" title="6、显示结果定向至文件"></a>6、显示结果定向至文件</h5><p><code>echo &quot;ls&quot; &gt; myfile</code></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
